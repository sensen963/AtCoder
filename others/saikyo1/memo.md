# B

- Aのi番目を考えると自分より前(i > j)で`A[i] > A[j]`となるのがBでは合計K-1回出てくる．同様に(i < j)ではK回出てくる
- これを1順目のAだとして考えるとk順目のAではK - k, K - k　+ 1回となる
- 合計すると$\sum_k (K - k)$,$\sum_k (K - k + 1)$
- 各i, jについて考えると答え

# C

- 左から順に考える．このときi番目について考えているときiより左のものは反転が確定している
- Wだった場合反転回数が偶数,Bだった場合奇数になる
- i番目の文字で枝(仮)を伸ばすか結ぶかを行うことができる
    - i文字目がBかWか，cが偶数か奇数かで取れる行動は決まる
    - 伸ばすとき1通りしか行動できない
    - 結ぶときは現在伸びている$c_i$の枝から1本選んで結ぶ
- 合計N本の枝ができるはずなので枝の順序(N!)をかけておわり
- 最終的にcが0でなければ結べない(実行不可能)ので0にする
- 単純に現在の枝の本数をかけてあげることで今後の枝の増減を無視して状態を列挙できるのかがイマイチ理解できていない

# D

- 偶数回の移動=二部グラフ
- つまり頂点数Nのグラフを二部グラフに分割すると偶数回の移動でしか戻ってこれなくなる
    - 必ずしも行って帰ってくる必要がないのがミソ
- 最も効率よく2部グラフに分割するとき，頂点数がそれぞれ等しくなるように分割
    - 半分に割る
    - 1~Nを分割すると1~N/2とN/2+1~Nになる
    - これらの頂点間に枝を貼る
- 同様のことを再帰的に実行
- 分割した領域内はそれぞれ以前のラベルでしか連結していないので次のステップで同じラベルを付けても良いのがミソ
    - 1~Nをラベルkで二部グラフにすると1~N/2とN/2+1~Nでは同じk+1のラベルを使用しても良い(k+1では連結していないから)